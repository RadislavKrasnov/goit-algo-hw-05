```
Algorithm          | Pattern      | Time        
------------------------------------------------
kmp_search         | Висновки     | 0.003227    
kmp_search         | Fake-value   | 0.002771    
boyer_moore_search | Висновки     | 0.001163    
boyer_moore_search | Fake-value   | 0.000909    
rabin_karp_search  | Висновки     | 0.007880    
rabin_karp_search  | Fake-value   | 0.009961 
```

# Висновки до завдання 3
Було реалізовано замір часу виконання 3-х алгоритмів пошуку підстроки у рядку: Боєра-Мура, Кнута-Морріса-Пратта та Рабіна-Карпа.  
Результати представлені у таблиці вищє. 
Можна побачити що найефективнішим відпрацював алгоритм  Боєра-Мура.   
Він виконуєтья за найменший час як для інсуючого значення в головному рядку, так і для не існуючого.  
Найгірший за часом виконаяння є алгоритм Рабіна-Карпа.  
Нижче було розглянутр кожен алгоритм окремо. Пояснення принципу його роботи, та випадки ефективного застосування.  

### KMP
KMP алгоритм має приблизно однаковий час для існуючого та неіснуючого значення в тексті.  
Це пов'язано з тим, що він створює таблицю LSP, яка зберігає часткові патерни наявні в самому патерні, який ми шукаємо.  
Потім ця таблиця часткового співпадіння дозволяє пропускати перевірки символів на кожному індексі головного рядка.  
Якщо у нас немає співпадіння, то патерн зсувається на кількість індексів обрахованих у таблиці.  
Але коли патерн взагалі не інсує в пошуковій строці, то алгоритм проходить цілий текст патерну один за одним.  
Тобто, при неіснуючому значенні ефективність LSP втрачається.  
Це призводить до погіршення часу виконання.  
Найбільш ефективно використовувати цей алгоритм на малих пертенах, які також мають повторювані підпатерни.  
Наприклад, при пошуку патернів у ДНК коді, функції пошуку та заміни у текстових редакторах.  

### Boyer-Moore
Демонструє найкращі результати по всім показниками.  
Його перевага в тому, що він може використовувати таблиці кількості індексів для зсуву патерну у випадку не співпадіння символів.  
Існують Bad character та good character правила зсуву. Завдяки цим таблицям та привилам він перескакує неспівпадіння.  
Такий підхід дає можливість швидко проходити по тексту і відшукувати співпадіння.  
Ефективний при великих патернах із рідкою повторбваністю симовлами в ньому. Хорошо працює при пошуку у великих текстах.  
Наприклад, у пошукових системах, перевірках на плагіат і т.д.  

### Rabin-Karp
Основною концепцією роботи цього алгоритму є те, що він вираховує хеш значення паттерну, а потім  
проходить вздовж усього тексту шукаючи підрядки патерну і обраховуючи хеші підрядків.  
Якщо хеші збігаються, то починається посимвольне порівняння підрядків і патерну.  
В нашому випадку пошук неіснуючого значення в тексті має гірший час виконання, ніж пошук інсуючого.  
Це через те, що в нашому коді ми одразу повертаємо занйдене значення. Якщо занчення не знаходитья, то  
код проходить циклом по всьому рядку пошуку, тому час виконання скрипта збільшується.  
Ефективний, коли маємо шукати декліька патернів, або коли занчєння в тексті зустрічаються дуже рідко.  
Наприклад, пошку ключових слів у тексті, перевірка емейлів на спам,  
у кібербезпеці при виявленні зловмисних шаблонів у мережевому трафіку, виявлення вторгнень та аналіз  
зловмисного програмного забезпечення.  
